este acordat distribuitorilor săi conform unui acord de licenţă aplicabil, în favoarea Sublicenţiatului şi a furnizorilor săi, acord care conţine termenii ce protejează compania Adobe în aceeaşi măsură în care o fac Termenii Adobe.</p>  
<p>4. Open source. Sublicenţiatul nu va acorda în mod direct sau indirect şi nu va pretinde că va acorda niciunei terţe părţi niciun drept sau imunitate conform drepturilor de proprietate sau drepturilor de proprietate intelectuală Adobe care vor supune respectiva proprietate intelectuală unei licenţe sau unei scheme open source în care există sau poate fi interpretată existenţa unei cerinţe conform căreia, drept condiţie de utilizare, modificare şi/sau distribuţie, software-ul Adobe va fi: (i) divulgat sau distribuit sub formă de cod sursă; (ii) licenţiat în scopul creării de lucrări derivative; (iii) redistribuit în mod gratuit. Pentru clarificare menţionăm că restricţia de mai sus nu împiedică Sublicenţiatul să distribuie, iar Sublicenţiatul chiar va distribui Software-ul Adobe împreună cu Software-ul Google, în mod gratuit.</p>
<p>5. Termenii adiţionali. În ceea ce priveşte toate actualizările, trecerile la versiuni superioare, versiunile noi ale Software-ului Adobe (colectiv numite „Actualizări”) furnizate Sublicenţiatului, Adobe îşi rezervă dreptul de a solicita termeni şi condiţii suplimentare aplicabile în mod exclusiv Actualizărilor şi versiunilor viitoare ale acestora şi numai în măsura în care respectivele restricţii sunt impuse de către Adobe tuturor licenţiaţilor respectivelor Actualizări. În cazul în care Sublicenţiatul nu este de acord cu aceşti termeni sau condiţii adiţionale, Sublicenţiatul nu va deţine niciun drept de licenţă asupra acestei Actualizări, iar drepturile de licenţă ale Sublicenţiatului pentru Software-ul Adobe se vor încheia în mod automat la 90 de zile după ce respectivii termeni adiţionali au fost puşi la dispoziţia Sublicenţiatului.</p>  
<p>6. Notificările privind drepturile de proprietate. Sublicenţiatul nu va şterge şi nu va modifica în vreun fel notificările privind drepturile de autor, mărcile comerciale, siglele sau notificările similare ori alte notificări privind drepturile de proprietate ale companiei Adobe (şi ale licenţiatorilor acesteia, dacă este cazul) care apar pe sau în cadrul Software-ului Adobe sau al materialelor care îl însoţesc şi va solicita distribuitorilor săi să aibă aceeaşi conduită.</p>
<p>7. Cerinţele tehnice. Sublicenţiatul şi distribuitorii săi pot distribui Software Adobe şi/sau Actualizarea numai pe dispozitive care (i) respectă specificaţiile tehnice postate pe http://www.adobe.com/mobile/licensees (sau pe un site succesor al acestuia) şi (ii) care au fost verificate de către Adobe conform stipulărilor de mai jos.</p>
<p>8. Verificarea şi actualizarea. Sublicenţiatul trebuie să trimită la Adobe fiecare produs al său (şi fiecare versiune a acestora) care conţine Software Adobe şi/sau Actualizarea („Produs al sublicenţiatului”) care nu se conformează criteriilor de scutire de Verificare a dispozitivelor comunicate de către Google, pentru ca Adobe să le verifice. Sublicenţiatul va plăti pentru fiecare trimitere efectuată achiziţionând pachete de verificare conform termenilor în vigoare stipulaţi de Adobe în momentul respectiv la adresa http://flashmobile.adobe.com/. Este interzisă distribuirea unui produs al Sublicenţiatului care nu a trecut de etapa de verificare. Verificarea va fi realizată în conformitate cu procesul Adobe în vigoare în momentul respectiv, descris la adresa http://flashmobile.adobe.com/ („Verificare”).</p>
<p>9. Profiluri şi Device Central. Sublicenţiatului i se va solicita introducerea anumitor informaţii de profil despre Produsele Sublicenţiatului, fie ca parte a procesului de Verificare, fie prin altă metodă, iar Sublicenţiatul va furniza aceste informaţii companiei Adobe. Adobe poate să (i) utilizeze astfel de informaţii de profil în limita necesităţilor rezonabile pentru a verifica Produsul Sublicenţiatului (dacă un astfel de produs este supus Verificării) şi să (ii) afişeze astfel de informaţii de profil în „Adobe Device Intelligence system” aflat la https://devices.adobe.com/partnerportal/ şi pus la dispoziţie prin intermediul instrumentelor şi al serviciilor Adobe de creare şi de dezvoltare pentru a permite programatorilor şi utilizatorilor finali să vadă în ce mod sunt afişate conţinutul şi aplicaţiile în Produsele Sublicenţiatului (de ex., modul în care imaginile video apar pe anumite telefoane).</p>  
<p>10. Exportul. Sublicenţiatul recunoaşte că legile şi reglementările din Statele Unite ale Americii restricţionează exportul şi reexportul bunurilor şi ale datelor tehnologice originare din Statele Unite, care pot include Software Adobe. Sublicenţiatul este de acord să nu exporte şi nici să nu reexporte Software Adobe în lipsa permisiunilor guvernamentale adecvate din Statele Unite ale Americii şi din străinătate, dacă este cazul.</p>
<p>11. Termenii pentru tehnologia directă.</p>  
<p>(a) Cu excepţia situaţiilor care decurg din permisiunile sau acordurile aplicabile de mai sus, în cazul părţilor cărora li se aplică, Sublicenţiatul nu va utiliza şi nu va permite utilizarea Software-ului Adobe pentru codificarea sau decodificarea de date care sunt exclusiv date audio mp3 (.mp3) pe niciun dispozitiv, cu excepţia sistemelor PC, (de ex., pe telefon mobil sau dispozitiv de decodare). De asemenea, codificatorii sau decodoarele mp3 conţinuţi în Software-ul Adobe Software nu pot fi utilizaţi sau accesaţi de niciun produs în afară de Software-ul Adobe. Software-ul Adobe poate fi utilizat pentru codificarea şi decodificarea datelor MP3 conţinute într-un fişier swf sau flv care are conţinut video, imagine sau alte date. Sublicenţiatul va recunoaşte că utilizarea Software-ului Adobe pentru alte dispozitive decât pentru calculatoare, conform interdicţiilor din această secţiune, poate necesita plata de taxe de licenţiere sau de alte sume unor terţe părţi care pot deţine drepturi de proprietate intelectuală care ţin de tehnologia MP3 şi că nici Adobe, nici Sublicenţiatul nu au plătit niciun fel de taxe sau alte sume pentru drepturile de proprietate intelectuală aparţinând terţelor părţi pentru acest tip de utilizare. Dacă Sublicenţiatul are nevoie de un codificator sau de un decodor MP3 pentru o astfel de utilizare, Sublicenţiatul este responsabil pentru obţinerea licenţei de proprietate intelectuală necesare, inclusiv a tuturor drepturile de brevet aplicabile.</p>
<p>(b) Sublicenţiatul nu va utiliza, copia, reproduce sau modifica (i) codul sursă On2 (furnizat mai jos în calitate de componentă a Codului sursă) care este necesar pentru ca Software-ul Adobe să decodifice conţinut video în formatul video Flash (.flv sau .f4v) şi (ii) codul sursă Sorenson Spark (furnizat mai jos în calitate de componentă a Codului sursă) în scopul limitat de a remedia erorile şi de a îmbunătăţi performanţele Software-ului Adobe. Toate codecurile furnizate împreună cu Software-ul Adobe pot fi utilizate şi distribuite numai ca parte componentă a Software-ului Adobe şi nu pot fi accesate de o altă aplicaţie, inclusiv de alte aplicaţii Google.</p>  
<p>(c) Codul sursă poate fi furnizat cu un codec AAC şi/sau HE-AAC („Codecul AAC”). Utilizarea Codecului AAC este condiţionată de obţinerea de către Sublicenţiat a unei licenţe de brevet adecvate care acoperă brevetele necesare aşa cum sunt furnizate acestea de VIA Licensing, pentru produse finale cu care sau în care va fi utilizat codecul AAC. Sublicenţiatul recunoaşte şi acceptă faptul că Adobe nu furnizează o licenţă de brevet pentru un Codec AAC în cadrul acestui Acord nici Sublicenţiatului, nici sublicenţiatorilor acestuia.</p>
<p>(d) CODUL SURSĂ POATE CONŢINE COD LICENŢIAT SUB LICENŢA AVC PATENT PORTFOLIO PENTRU UZUL PERSONAL, NECOMERCIAL AL UNUI CONSUMATOR PENTRU A (i) CODIFICA CONŢINUT VIDEO ÎN CONFORMITATE CU STANDARDUL AVC („VIDEO AVC”) ŞI/SAU A (ii) DECODIFICA CONŢINUT VIDEO CARE A FOST CODIFICAT DE UN UTILIZATOR ÎN CADRUL UNEI ACTIVITĂŢI PERSONALE, NECOMERCIALE ŞI/SAU CARE A FOST OBŢINUT DE LA UN FURNIZOR VIDEO LICENŢIAT PENTRU FURNIZAREA DE CONŢINUT VIDEO AVC. NU SE ACORDĂ ŞI NU SE SUGEREAZĂ ACORDAREA NICIUNEI LICENŢE PENTRU NICIUN ALT SCOP. INFORMAŢII SUPLIMENTARE POT FI OBŢINUTE DE LA MPEG LA, L.L.C. Consultaţi http://www.mpegla.com</p>
<p>12. Actualizarea. Sublicenţiatul nu se va sustrage eforturilor depuse de Google sau de Adobe pentru a actualiza Software-ul Adobe din toate produsele Sublicenţiatului care includ Software Adobe aflate în acelaşi pachet cu Software-ul Google („Produse ale Sublicenţiatului”).</p>  
<p>13. Notificările privind Atribuirea şi Proprietatea. Sublicenţiatul va menţiona Software-ul Adobe în specificaţiile disponibile publicului ale Produselor Sublicenţiatului şi va include elementele de marcă Software Adobe adecvate (excluzând în special sigla corporaţiei Adobe) de pe ambalajul Produselor Sublicenţiatului şi din materialele de marketing într-un mod consecvent cu brandingul pentru alte produse terţă parte conţinute în Produsul Sublicenţiatului.</p>
<p>14. Nicio garanţie. SOFTWARE-UL ADOBE ESTE PUS LA DISPOZIŢIA SUBLICENŢIATULUI ÎN SCOPUL UTILIZĂRII ŞI AL REPRODUCERII „CA ATARE”, IAR COMPANIA ADOBE NU OFERĂ NICIO GARANŢIE CU PRIVIRE LA UTILIZAREA SAU PERFORMANŢELE ACESTUIA. ADOBE ŞI FURNIZORII SĂI NU GARANTEAZĂ ŞI NU POT GARANTA PERFORMANŢA SAU REZULTATELE OBŢINUTE UTILIZÂND SOFTWARE-UL ADOBE. EXCEPTÂND TOATE GARANŢIILE, CONDIŢIILE, DECLARAŢIILE SAU TERMENII, CARE NU POT FI LIMITAŢI SAU EXCLUŞI CONFORM LEGILOR APLICABILE SUBLICENŢIATULUI ÎN JURISDICŢIA ÎN CARE SE AFLĂ ACESTA, ADOBE ŞI FURNIZORII SĂI NU OFERĂ NICIO GARANŢIE, NICIO CONDIŢIE, NICIO DECLARAŢIE ŞI NICIUN TERMEN (NICI EXPLICIT, NICI IMPLICIT, INDIFERENT DACĂ ESTE VORBA DE STATUT, DREPT COMUNITAR, OBICEI, UZANŢĂ SAU ALTĂ SITUAŢIE) ÎN NICIO PRIVINŢĂ, INCLUZÂND, FĂRĂ LIMITĂRI, NEÎNCĂLCAREA DREPTURILOR TERŢELOR PĂRŢI, VANDABILITATEA, INTEGRABILITATEA, CALITATEA SATISFĂCĂTOARE SAU ADECVAREA PENTRU UN ANUMIT SCOP. SUBLICENŢIATUL ESTE DE ACORD CĂ SUBLICENŢIATUL NU ARE DREPTUL DE A OFERI NICIO GARANŢIE, FIE ACEASTA EXPLICITĂ, FIE IMPLICITĂ, ÎN NUMELE COMPANIEI ADOBE.</p>  
<p>15. Limitarea răspunderii. INDIFERENT DE SITUAŢIE, ADOBE SAU FURNIZORII SĂI NU VOR FI RESPONSABILI FAŢĂ DE SUBLICENŢIAT PENTRU NICIUN FEL DE DAUNE, REVENDICĂRI SAU COSTURI ŞI PENTRU NICIO DAUNĂ DERIVATĂ, INDIRECTĂ SAU INCIDENTALĂ, PENTRU NICIO PIERDERE DE PROFIT SAU DE ECONOMII ŞI PENTRU NICIO REVENDICARE PROVENITĂ DE LA O TERŢĂ PARTE, CHIAR DACĂ UN REPREZENTANT ADOBE A FOST INFORMAT CU PRIVIRE LA POSIBILITATEA SURVENIRII PIERDERILOR, DAUNELOR, REVENDICĂRILOR SAU A COSTURILOR MENŢIONATE MAI SUS. LIMITĂRILE ŞI EXCLUDERILE DE MAI SUS SE APLICĂ ÎN MĂSURA PERMISĂ DE LEGISLAŢIA APLICABILĂ ÎN JURISDICŢIA ÎN CARE SE AFLĂ SUBLICENŢIATUL. RESPONSABILITATEA CUMULATĂ A COMPANIEI ADOBE ŞI A FURNIZORILOR SĂI CONFORM ACESTUI ACORD SAU ÎN LEGĂTURĂ CU ACESTA VA FI LIMITATĂ LA SUMA DE O MIE DE DOLARI AMERICANI (1.000 USD). Niciuna dintre prevederile prezentului Acord nu limitează responsabilitatea companiei Adobe în caz de deces sau rănire care decurge din neglijenţa companiei Adobe sau din înşelătorie din culpă (fraudă). Adobe acţionează în numele furnizorilor săi în scopul declinării, excluderii şi/sau al limitării obligaţiilor, a garanţiilor şi a responsabilităţii conform prevederilor acestui Acord, dar nu şi în alte privinţe sau scopuri.</p>
<p>16. Termenii privind protejarea conţinutului</p>
<p>(a) Definiţii.</p>
<p>„Regulile privind conformitatea şi robusteţea” se referă la documentul care stipulează regulile de conformitate şi robusteţe pentru Software-ul Adobe, acestea aflându-se la http://www.adobe.com/mobile/licensees sau pe un site succesor al a  * Wraps a Swift_Message in a message/rfc822 MIME part.
     *
     * @return Swift_MimePart
     */
    protected function wrapMimeMessage(Swift_Message $message)
    {
        // Start by copying the original message into a message stream
        $messageStream = new Swift_ByteStream_TemporaryFileByteStream();
        $message->toByteStream($messageStream);
        $messageStream->commit();

        // Create a new MIME part that wraps the original stream
        $wrappedMessage = new Swift_MimePart($messageStream, 'message/rfc822');
        $wrappedMessage->setEncoder(new Swift_Mime_ContentEncoder_PlainContentEncoder('7bit'));

        return $wrappedMessage;
    }

    protected function parseSSLOutput(Swift_InputByteStream $inputStream, Swift_Message $message)
    {
        $messageStream = new Swift_ByteStream_TemporaryFileByteStream();
        $this->copyFromOpenSSLOutput($inputStream, $messageStream);

        $this->streamToMime($messageStream, $message);
    }

    /**
     * Merges an OutputByteStream from OpenSSL to a Swift_Message.
     */
    protected function streamToMime(Swift_OutputByteStream $fromStream, Swift_Message $message)
    {
        // Parse the stream into headers and body
        list($headers, $messageStream) = $this->parseStream($fromStream);

        // Get the original message headers
        $messageHeaders = $message->getHeaders();

        // Let the stream determine the headers describing the body content,
        // since the body of the original message is overwritten by the body
        // coming from the stream.
        // These are all content-* headers.

        // Default transfer encoding is 7bit if not set
        $encoding = '';
        // Remove all existing transfer encoding headers
        $messageHeaders->removeAll('Content-Transfer-Encoding');
        // See whether the stream sets the transfer encoding
        if (isset($headers['content-transfer-encoding'])) {
            $encoding = $headers['content-transfer-encoding'];
        }

        // We use the null content encoder, since the body is already encoded
        // according to the transfer encoding specified in the stream
        $message->setEncoder(new Swift_Mime_ContentEncoder_NullContentEncoder($encoding));

        // Set the disposition, if present
        if (isset($headers['content-disposition'])) {
            $messageHeaders->addTextHeader('Content-Disposition', $headers['content-disposition']);
        }

        // Copy over the body from the stream using the content type dictated
        // by the stream content
        $message->setChildren([]);
        $message->setBody($messageStream, $headers['content-type']);
    }

    /**
     * This message will parse the headers of a MIME email byte stream
     * and return an array that contains the headers as an associative
     * array and the email body as a string.
     *
     * @return array
     */
    protected function parseStream(Swift_OutputByteStream $emailStream)
    {
        $bufferLength = 78;
        $headerData = '';
        $headerBodySeparator = "\r\n\r\n";

        $emailStream->setReadPointer(0);

        // Read out the headers section from the stream to a string
        while (false !== ($buffer = $emailStream->read($bufferLength))) {
            $headerData .= $buffer;

            $headersPosEnd = strpos($headerData, $headerBodySeparator);

            // Stop reading if we found the end of the headers
            if (false !== $headersPosEnd) {
                break;
            }
        }

        // Split the header data into lines
        $headerData = trim(substr($headerData, 0, $headersPosEnd));
        $headerLines = explode("\r\n", $headerData);
        unset($headerData);

        $headers = [];
        $currentHeaderName = '';

        // Transform header lines into an associative array
        foreach ($headerLines as $headerLine) {
            // Handle headers that span multiple lines
            if (false === strpos($headerLine, ':')) {
                $headers[$currentHeaderName] .= ' '.trim($headerLine);
                continue;
            }

            $header = explode(':', $headerLine, 2);
            $currentHeaderName = strtolower($header[0]);
            $headers[$currentHeaderName] = trim($header[1]);
        }

        // Read the entire email body into a byte stream
        $bodyStream = new Swift_ByteStream_TemporaryFileByteStream();

        // Skip the header and separator and point to the body
        $emailStream->setReadPointer($headersPosEnd + strlen($headerBodySeparator));

        while (false !== ($buffer = $emailStream->read($bufferLength))) {
            $bodyStream->write($buffer);
        }

        $bodyStream->commit();

        return [$headers, $bodyStream];
    }

    protected function copyFromOpenSSLOutput(Swift_OutputByteStream $fromStream, Swift_InputByteStream $toStream)
    {
        $bufferLength = 4096;
        $filteredStream = new Swift_ByteStream_TemporaryFileByteStream();
        $filteredStream->addFilter($this->replacementFactory->createFilter("\r\n", "\n"), 'CRLF to LF');
        $filteredStream->addFilter($this->replacementFactory->createFilter("\n", "\r\n"), 'LF to CRLF');

        while (false !== ($buffer = $fromStream->read($bufferLength))) {
            $filteredStream->write($buffer);
        }

        $filteredStream->flushBuffers();

        while (false !== ($buffer = $filteredStream->read($bufferLength))) {
            $toStream->write($buffer);
        }

        $toStream->commit();
    }
}
